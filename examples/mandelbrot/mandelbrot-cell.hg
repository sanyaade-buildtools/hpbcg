#include <stdio.h> /* -*- c -*- */
#include <stdlib.h>
#include <pthread.h>
#include <assert.h>
#include <malloc_align.h>
#include <free_align.h>
#include <libspe2.h>

#include "mandelbrot-common.h"

#cpu cell

typedef float (*pifdd) (tComplex *a);
pifdd isInSet;

tComplex ConstZero   = { 0.0f, 0.0f };

#define SendComplex(CTX, VAL)					\
  spe_in_mbox_write(CTX, (unsigned int *) &VAL,			\
		    1, SPE_MBOX_ANY_NONBLOCKING);
#define GetComplex(CTX, VAL)						\
  spe_out_intr_mbox_read(CTX, (unsigned int *) &VAL,			\
			 1, SPE_MBOX_ALL_BLOCKING);



pifdd isInSetCompile(int limit)
{
  insn * code= (insn *)_malloc_align(1024, 7);
  int rZ, rC, rTmp, rLimit, rI;

  rC = 3;   // Floating registers 3 contain C
  rZ = 4;   // Floating registers 4 contain Z
  rLimit = 5;
  rTmp = 6;
  rI = 7;    
  #[	.org	code  
     il $(rLimit), (limit)
     il $(rI), 0
     fs $(rZ), $(rZ), $(rZ)
     fm $(rC), $(rC), $(rC)
     bi $lr 
   ]#
   return (pifdd) code;
}

void *waitingThread(void * arg)
{
  spe_program_handle_t *spu_handle;
  spe_stop_info_t stop_info;
  spe_context_ptr_t ctx = *(spe_context_ptr_t *) arg;  
  unsigned int entry = SPE_DEFAULT_ENTRY;

  /* Load wrapper SPU code */
  spu_handle = spe_image_open("./simple-worker-cell");
  assert(NULL != spu_handle);
  spe_program_load(ctx, spu_handle);
  /* Send and launch the code */
  spe_context_run(ctx, &entry, 0, isInSet, NULL, &stop_info);
  pthread_exit(0);
}

int main(int argc, char * argv[])
{
  pthread_t pthread;
  spe_context_ptr_t ctx;
  tComplex Center, C1, C2;
  tReal reInc, imInc, reSize, imSize;
  int IMGXSIZE, IMGYSIZE, i, j;
  int COLORMAPSIZE = 65536; 
  int ITERLIMIT = 256;
  tComplexUnion res;
  if (argc <= 6)
    {
      fprintf(stderr, "%s [Cr] i[Ci] re[Size] i[Size] imgXsize imgYsize\n", argv[0]);
      fprintf(stderr, "C = Center, B = bottom rigth\n");
      fprintf(stderr, "Example : %s 0.0    0.0 3    3    1280 1024\n", argv[0]);
      exit(0);
    }

  cSet(&Center, atof (argv[1]), atof (argv[2]));
  reSize     = atof (argv[3]);  imSize   = atof (argv[4]);
  IMGXSIZE   = atoi (argv[5]);
  IMGYSIZE   = atoi (argv[6]);
  fprintf(stderr, "Mendelbrot set (power4 compilette support) : ");  pComplex(Center, stderr); 
  fprintf(stderr, "Size     : %2.2f %2.2f ", reSize, imSize);
  fprintf(stderr, "Img Size : %dx%d\n",IMGXSIZE, IMGYSIZE);
  reInc = reSize / IMGXSIZE;
  imInc = imSize / IMGYSIZE;
  cSet(&C1, RE(Center) - (reSize / 2.0f), IMAG(Center) - (imSize / 2.0f));
  (void) printf("P3\n");  
  (void) printf("%d %d\n", IMGXSIZE, IMGYSIZE);  
  (void) printf("%d\n", 256);  

  isInSet = isInSetCompile(ITERLIMIT);
  ctx = spe_context_create(0, NULL);		 /* Send it to worker */
  pthread_create(&pthread, NULL, &waitingThread, &ctx);

  for (i = 0; i < IMGYSIZE; i++)
    {
      C2 = C1;
      for (j = 0; j < IMGXSIZE; ++j)
	{
	  SendComplex(ctx, C2.re);       	/* Send parameters */
	  SendComplex(ctx, C2.im);       	
	  GetComplex(ctx, res.u.intValues[0]); /* Receive results */
	  GetComplex(ctx, res.u.intValues[1]);
	  printf("%2.2f %2.2f\n", res.u.complexValues.re, res.u.complexValues.im);
	  RE(C2) += reInc;
	}
      IMAG(C1) += imInc;
      printf("\n");
    }
  return 0;
}
