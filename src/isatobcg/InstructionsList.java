// This file is part of HPBCG
// List of asm instructions
import java.util.*;

class InstructionsList
{
    String archName;
    int isaLen;
    Vector instructionList = new Vector();
    Instruction cI;
    public void setNameAndLenght (String archName, int isaLen)
    {
	this.archName = archName;
	this.isaLen = isaLen;
    }
    String header()
    {

	StringBuffer tmp = new StringBuffer("/* Autogenerated file, do not edit ! */\n");
	tmp.append("/* "+ archName +" "+ isaLen+ " bits  */\n");
	tmp.append("#include <hpbcg-"+archName+"-utils.h>\n");
	return tmp.toString();
    } /* header */

    public String toString()
    {
	StringBuffer tmp = new StringBuffer(header());
	tmp.append("#if WITH_HPBCG_FUNCTIONS\n");
	for (int i = 0; i < instructionList.size(); ++i)
	    tmp.append(((Instruction) instructionList.elementAt(i)).toMacro());
	tmp.append("#else /* WITH_HPBCG_FUNCTIONS */\n");
	for (int i = 0; i < instructionList.size(); ++i)
	    tmp.append(((Instruction) instructionList.elementAt(i)).toFunction());
	tmp.append("#endif /* WITH_HPBCG_FUNCTIONS */\n");
	return tmp.toString();
    } /* toString() */

    public boolean checkLength()
    {
	boolean isOk = true;
	int len;
	Instruction insn;
	for (int i = 0; i < instructionList.size(); ++i)
	{
	    insn = (Instruction) instructionList.elementAt(i);
	    len = insn.getLength();
	    if (isaLen != len)
	    {
		isOk = false;
		System.err.println("Incorrect size "+len+" (should be "+isaLen+") for insn " +insn.getName());
	    }
	}
	return isOk;
    } /* checkLength */

    public String getInsnList()
    {
	String tmp = "";

	for (int i = 0; i < instructionList.size(); ++i)
	    tmp += ((Instruction) instructionList.elementAt(i)).getName()+ "\n";
	return tmp;
    } /* getInsnList */

    public void Verify()
    {
	if (null == cI) 
	    cI = new Instruction(archName);
    }
    void addInstruction()
    {
	instructionList.add (cI);
	cI = null;
    } /* addInstruction */
    void addName(String insnName)
    {
	cI.setName(insnName);
    } /* addName */

    void addBinaryNumber(String n)
    {
	Verify();
	cI.addBinaryNumber(Integer.parseInt(n, 2), n.length());
    } /* addBinaryNumber */

    void addBinaryIntExpr (String n)
    {
	int i; 
	String expr = "", intEnd = "" , intStart = "";;
	Verify();

	for (i = 1; ')' != n.charAt(i) ; ++i)
	    expr += n.charAt(i);
	// Pass ")_" 
	for (i+= 2; '-' != n.charAt(i) ; ++i)	    intEnd += n.charAt(i);
	for (i++; i < n.length(); ++i)		    intStart += n.charAt(i);
	cI.addBinaryIntExpr(expr, Integer.parseInt(intStart), 
			    Integer.parseInt(intEnd));
    }
    void addBinaryIntDescr(String n)
    {
	int i;
	String intNumber = "", intEnd = "" , intStart = "";
	Verify();
	// Number has this form iN_E-S
	try {
	    for (i = 1; '_' != n.charAt(i) ; ++i) intNumber += n.charAt(i);
	    for (i++; '-' != n.charAt(i) ; ++i)   intEnd += n.charAt(i);
	    for (i++; i < n.length(); ++i)		  intStart += n.charAt(i);
	    cI.addBinaryIntDescr(Integer.parseInt(intNumber), 
				 Integer.parseInt(intStart), 
				 Integer.parseInt(intEnd));
	}
	catch (java.lang.StringIndexOutOfBoundsException e)
	    {
	cI.addBinaryIntDescr(Integer.parseInt(intNumber), 
		       Integer.parseInt(intEnd) ,Integer.parseInt(intEnd));

	    }
    } /* addBinaryIntDescr */

    void addBinaryRegDescr(String descr)
    {
	int i;
	String regName= "", number = "", size = "";
	Verify();
	// regName Interger1 _ Interger2
	for (i = 0; Character.isLetter(descr.charAt(i)) ; ++i)	regName += descr.charAt(i);
	for (     ; '_' != descr.charAt(i) ; ++i)	number += descr.charAt(i);
	for (i++; i < descr.length(); ++i)		size += descr.charAt(i);
	cI.addBinaryRegDescr(regName, Integer.parseInt (number), Integer.parseInt (size));
    } /* addBinaryRegDescr */

    void addAsmReg(String r)
    {
	cI.addAsmReg(r);
    } /* addAsmReg */

    void addAsmInt(String r)
    {
	cI.addAsmInt(r);
    } /* addAsmInt */
}