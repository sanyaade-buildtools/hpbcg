\documentclass{article}
\usepackage{url}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\title{HPBCG Documentation\\
High Performance Binary Code Generation}
\author{Henri-Pierre Charles}
\newcommand{\hpbcg}{\textbf{HPBCG}\ }
\newcommand{\Image}[2][10]{\includegraphics[width=#1cm]{Img/#2}}
\newcommand{\Fig}[2]{\includegraphics[width=#2cm]{Img/#1}}
\begin{document}
\maketitle
\tableofcontents{}

\section{Introduction}

\hpbcg is a tool which help to build binary code generator.

\subsection{What is it ?}

A binary code generator is a tool which can generate binary code
(runnable), at run-time, without using assembly (textual)
representation.

It can be usefull in a lot of situations :
\begin{itemize}
\item For vector code generation
\item For multimedia code generation
\item For code optimization at run-time using data as optimizing parameter
\end{itemize}

\subsection{Motivation}

Actually (january 2009) computer architecture reach a complexity
point which leed to
\begin{itemize}
\item compiler which are unable to vectorize or use multimedia
  instructions easily
\item a bad use of huge register set. Compiler are still using
  algorithm allocator which came from ages where register are rare.
\item data are the main important parameter that actual compiler
  cannot take into account because code generation is done at static
  compile time.
\end{itemize}

\subsection{Related projects}

\begin{description}
\item[ccg] C Code Generator \cite{2001Piumarta} is the direct
  predecessor of \hpbcg. \hpbcg differ from ccg on many points :
  \begin{itemize}
  \item The architecture description has been simplified to the strict
    minimal binary description.
  \item The source parser has been rewrited using antlr, which greatly
    simplify the porting process
  \end{itemize}
\item[lightning] \url{http://www.gnu.org/software/lightning/} is an
  other tool (which has take the architecture description from ccg),
  but it does not allow a full use of the large register set, the
  vector instructions or the special multimedia instructions.
\end{description}

\section{Actual status}

\begin{description}
\item[Cell spu] Working draft 
\item[Itanium]  Working draft.
\end{description}

Working demo / architecture :

\begin{tabular}{|l | c c|} \hline
  Demo name       & Cell-spu & Itanium  \\ \hline
  simple-multiply & ok & ok \\ \hline
\end{tabular}


\section{Todo}

\begin{description}
\item[itanium] Things to be done
  \begin{enumerate}
  \item Verify the intruction tabuled scheduler in \texttt{ia64-utils.h}
  \item Add a mini scheduler which allow to break bundle into
    sub-bundle if a schedule does not exist
  \end{enumerate}
\item[cell] Things to be done
  \begin{enumerate}
  \item Add more working examples
  \item Hide the worker communication somewhere
  \end{enumerate}
\end{description}

\section{Using \hpbcg}

\subsection{Installing \hpbcg}

\hpbcg sould work on any reasonnable unix like target. The
requirements are :
\begin{description}
\item[antlr] The parser is implemented with \url{antlr.org}
\item[java] As antlr is writed in java. But java is not needed at
  run-time, only at static compile time.
\end{description}

\hpbcg contain two parts :
\begin{description}
\item[Architecture description] contains the architecture description
  and the parser used to generate the macro instructions. This part is
  in the \texttt{src/isatobcg} directory.

  \begin{figure}
    \centering
    \Fig{IsaToHPBCGChain.pdf}{6}
    \caption{Installation scheme}
    \label{fig:Install}
  \end{figure}
\item[Parser] contains the parser in charge of the translation from
  the \texttt{.hg} file to the \texttt{.c} file. This par is in the
  \texttt{src/parser} directory.
\end{description}


\subsection{Using hpbcg}

\section{Compilettes examples}

\subsection{simple-multiply}

This example is very simple, it's just a proof of concept.

The obtained result is
\begin{verbatim}
turner:simple-multiply/>./simple-multiply-cell 42
Code generation for multiply value 42
Code generated
  1   2   3   4   5   6   7   8   9  10 
 42  84 126 168 210 252 294 336 378 420 
\end{verbatim}

The \texttt{simple-multiply} program should generate a specialized
version of a very simple program. The non specialized version is :
\begin{verbatim}
int multiply (int a, int b)
{
  return a * b;
}
\end{verbatim}

This compilette will specialize this code with an ``optimized''
version at run-time. For example the previous code will be specialized
as
\begin{verbatim}
int multiply (int a)
{
  return a * 42;
}
\end{verbatim}

This specialized version shoud be faster than the previous one because
\begin{itemize}
\item the code is less specialized (Well, for a 1 instruction
  function, it's not so evident, but you get the idea)
\item the function contain less parameter, which use less memory and
  less register
\end{itemize}


\subsubsection{Cell version}

Use the command \texttt{make cell} to build the program.

The \texttt{cell} version contain 2 files :
\begin{description}
\item[simple-worker-cell.c] contain the initial SPU code. It will
  \begin{enumerate}
  \item download the binary code in a buffer
  \item use this buffer as a function
  \item call this function for all incoming parameter
  \end{enumerate}
\item[simple-multiply-cell.hg] is the code for the PPU. It will
  \begin{enumerate}
  \item generate a specialized code depending on the data given by the user.
  \item sent it to the worker
  \item use the worker 10 times for printing a array of multiplied values
  \end{enumerate}
\end{description}

\subsubsection{Itanium version}

Use the command \texttt{make ia64} to build the program \texttt{simple-multiply-ia64}.

\section{Porting \hpbcg}

Porting \hpbcg to a new architecture should be as simple than the
architectural model you plan to target.

\subsection{Architecture description}

The actual version contain processor description for 
\begin{description}
\item[cell.isa] This file contain all SPU instruction description
\item[ia64.isa] This file contain all instruction set description
\end{description}

A processor description file should contain
\begin{description}
\item[Comments] A comments line is a line starting with \#
\item[Arch length] A line containing the architecture name and the bit
  lenght of one instruction. For instance the first lone of the 
\verb|cell.isa| containing the cell description contain :
\begin{verbatim}
cell 32
\end{verbatim}
\item[Instruction description] Each line of this part describe one
  machine instruction. Each line is divided in two part separated by a
  \verb-|-. The general for is :

\begin{verbatim}
Binary description | Syntax description
\end{verbatim}

For instance the \verb|cell.isa| description contain a line with :
\begin{verbatim}
 00011000000  r3_7 r2_7  r1_7   | a   r1,r2,r3
\end{verbatim}
  \begin{description}
  \item[The Binary description] contains bits fields describing the
    instruction. In the previous example we have 4 bit fields
    \begin{description}
      \item[00011000000] witch is the opcode of the instruction
        comming from the manual\cite{SPU1} page 55.
      \item[Registers description] \verb|r3_7| which mean that the 3nd
        register should be encoded on 7 bits.
    \end{description}
  \item[Syntax description] contains the instruction syntax allowed to
    be used in compilettes.
  \end{description}

\end{description}

\subsection{isatobcg Parser}


\subsection{HPBCG Parser}

\section{Assembly languages}

This part is devoted to different assembly langaguages that \hpbcg

\subsection{cell-spu}

\begin{description}
\item[Integer register names] one of
  \begin{itemize}
  \item \verb|$lr|, \verb|$sp|
  \item \verb|$0| .. \verb|$32|
  \end{itemize}
\item[Calling convention] 
\end{description}

\subsection{cell-ppu}

\begin{description}
\item[Integer register name]  one of
  \begin{itemize}
  \item \verb|0| .. \verb|32|
  \end{itemize}
\item[Calling convention] 
\end{description}

\subsection{power}
\begin{description}
\item[Integer register name]  one of
  \begin{itemize}
  \item \verb|r0| .. \verb|r32|
  \end{itemize}
\item[Calling convention] 
\end{description}

\subsection{ia64}
\begin{description}
\item[Registers name] one of
  \begin{itemize}
  \item \verb|r0| .. \verb|r128|, \verb|f0| .. \verb|f0| are floating
    point or multimedia registers
  \item \verb|r0| is always 0
  \item \verb|r1| is always 1
  \item \verb|f0| is always 0.0
  \end{itemize}
\item[Calling convention] depending on the used datatype, differents
  register can be used :
  \begin{itemize}
  \item \verb|r32| is the first integer parameter, \verb|r33| the
    second, etc.
  \item \verb|f8| is the first floating point parameter, \verb|f9| the
    second, etc.
  \item \verb|r8| or \verb|f8| is the return value depending on the
    used data type.
  \end{itemize}
\end{description}

\section{Reporting bug}

Please mail your comments to \url{mailto:hpc@prism.uvsq.fr}

\bibliographystyle{plain}
\bibliography{HPBCG.bib}

\end{document}

% Local Variables: ***
% compile-command:"MonMake HPBCG.pdf" ***
% End: ***
