\documentclass{article}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\title{HPBCG Documentation\\
High Performance Binary Code Generation}
\author{Henri-Pierre Charles}
\newcommand{\hpbcg}{\textbf{HPBCG}\ }
\newcommand{\Image}[2][10]{\includegraphics[width=#1cm]{Img/#2}}
\newcommand{\Fig}[2]{\includegraphics[width=#2cm]{Img/#1}}

\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{numbers=left, language=C,
  backgroundcolor=\color{lbcolor},rulecolor=, frame=tb}
% \lstset{language=Java, caption=Descriptive Caption Text, label=DescriptiveLabel}
% \lstset{frame=shadowbox, rulesepcolor=\color{blue}}

\begin{document}
\maketitle
\tableofcontents{}

\section{Introduction}

\hpbcg is a tool which help to build binary code generator.

\subsection{What is it ?}

A binary code generator is a tool which can generate binary code
(runnable), at run-time, without using assembly (textual)
representation.

It can be useful in a lot of situations :
\begin{itemize}
\item For code optimization at run-time using data as optimizing parameter
\item For vector code generation
\item For multimedia code generation
\end{itemize}

\subsection{Motivation}

Actually (January 2009) computer architecture reach a complexity
point which lead to
\begin{itemize}
\item compiler which are unable to vectorize or use multimedia
  instructions easily
\item a bad use of huge register set. Compiler are still using
  algorithm allocator which came from ages where register are rare.
\item data are the main important parameter that actual compiler
  cannot take into account because code generation is done at static
  compile time.
\end{itemize}

\subsection{Related projects}

\begin{description}
\item[ccg] C Code Generator \cite{2001Piumarta} is the direct
  predecessor of \hpbcg. \hpbcg differ from ccg on many points :
  \begin{itemize}
  \item The architecture description has been simplified to the strict
    minimal binary description.
  \item The source parser has been rewrote using antlr, which greatly
    simplify the porting process
  \end{itemize}
\item[lightning] \url{http://www.gnu.org/software/lightning/} is an
  other tool (which has take the architecture description from ccg),
  but it does not allow a full use of the large register set, the
  vector instructions or the special multimedia instructions.
\end{description}

\section{Actual status}

\subsection{Working targets}

\begin{description}
\item[Itanium]  Working draft.
\item[Power4]  
  \begin{itemize}
    \item Basic power4 instruction set : Working draft
    \item Cell spu : Working draft 
    \item FP2 extension : Working draft
    \item Altivec extension : To be integrated
    \item Arm : To be integrated
  \end{itemize}
\end{description}

Working demo / architecture :

\begin{tabular}{|l | c c c|} \hline
  Demo name       & Cell-spu & Itanium  & Power4\\ \hline
  simple-multiply & ok       & ok       & ok \\ \hline
  rpn             & ok \footnote{Divide precision problem to be solved}      & compile  & ok \\ \hline
\end{tabular}

\subsection{Tested platforms}

\begin{tabular}{|r r r|} \hline
  cell-spu 		& power4 & itanium \\ \hline
  PS3 linux yellow dog  & Sony/PS3    & Bull ia64 / linux \\
                        & IBM/BlueGene &	\\ \hline
\end{tabular}

Java on PS3 :\url{http://www.ibm.com/developerworks/java/jdk/linux/} could be useful

\section{Todo}

\begin{description}
\item[All targets] Things to be done
  \begin{itemize}
  \item Improve the .isa verifyer, to check the insn coherency, the opcode
    usage.
  \item Find a way to handle instructions aliases
  \end{itemize}
\item[itanium] Things to be done :
  \begin{enumerate}
  \item Verify the instruction tabulated scheduler in \texttt{ia64-utils.h}
  \item Add a mini scheduler which allow to break bundle into
    sub-bundle if a schedule does not exist
  \item Look at the L+X instruction : how to choose the template value ?
  \item How to choose between two possible templates ?
  \end{enumerate}
\item[cell] Things to be done :
  \begin{enumerate}
  \item Add more working examples
  \item Hide the worker communication somewhere
  \item Solve the precision divide problem
  \end{enumerate}
\item[power4]  Things to be done :
  \begin{itemize}
  \item Complete the .isa file
  \item Test  FP2 on bluegene
  \end{itemize}
\end{description}

\section{Installing \hpbcg}

\hpbcg should work on any reasonable unix like target. The
requirements are :

\begin{tabular}{|l | l |}\hline
Build time          & java and antlr 3.x 	\\
Install time        & nothing 			\\
Static compile time & java and antlr 3.x 	\\
Run-time            & nothing 			\\ \hline
\end{tabular}

\hpbcg contain two parts :
\begin{description}
\item[Architecture description] contains the architecture description
  and the parser used to generate the macro instructions. This part is
  in the \texttt{src/isatobcg} directory.
  \begin{figure}
    \centering
    \Fig{IsaToHPBCGChain.pdf}{6}
    \caption{Installation scheme}
    \label{fig:Install}
  \end{figure}
\item[Parser] contains the parser in charge of the translation from
  the \texttt{.hg} file to the \texttt{.c} file. This parser is in the
  \texttt{src/parser} directory.

  This parser translate pseudo assembly file into fast binary code
  generator.
\end{description}

\subsection{Installation}

HPBCG can be installed everywhere, the usual location should be
\texttt{/usr/local}.

In the main directory type the commands :
\begin{verbatim}
make build
sudo make install WHERE=/usr/local
\end{verbatim}

\begin{enumerate}
\item The first one will create all the \texttt{.h} files
\item The second one will install the files in the \texttt{WHERE} directory.
\end{enumerate}

\section{Using \hpbcg}

Mainly \hpbcg is a parser which translate C code whith special parts
to a real C code. The text contain two parts inside compilette block
or outside

\subsection{Outside parser}

The outside parser only recognize the \verb|#cpu| token

\begin{itemize}
\item \verb|#cpu| : this allow to define the architecture which will be
  used in the future compilettes blocks
\end{itemize}

The actual cpu recognized cpu are 
\begin{itemize}
\item \verb|#cpu power4|
\item \verb|#cpu ia64|
\item \verb|#cpu cell|
\end{itemize}

\subsection{Inside parser}

The compilette block is delimited by theses tokens :  

\begin{itemize}
\item \verb|#[| : beginning of compilette block
\item \verb|]#| : end of compilette block
\end{itemize}

Inside a compilette block a programmer can write standard assembler
instructions. The used syntax for the assembly instructions is defined
by the previous \verb|#cpu| An example of CELL instruction :
\begin{verbatim}
	mpyi    $3, $3, 4
\end{verbatim}

The special characters \verb|(| and \verb|)| are used to insert C
expressions inside the assembly code. Please note that these
expressions wil be evaluated only at run-time.

It allow to write parametrized instruction. An example of CELL
instruction :
\begin{verbatim}
	mpyi    $3, $3, (multiplyValue) 
\end{verbatim}

\section{Compilettes examples}

\subsection{simple-multiply}

This example is very simple, it's just a proof of concept.

The obtained result is
\begin{verbatim}
turner:simple-multiply/>./simple-multiply-cell 42
Code generation for multiply value 42
Code generated
  1   2   3   4   5   6   7   8   9  10 
 42  84 126 168 210 252 294 336 378 420 
\end{verbatim}

The \texttt{simple-multiply} program should generate a specialized
version of a very simple program. The non specialized version is :
\begin{verbatim}
int multiply (int a, int b)
{
  return a * b;
}
\end{verbatim}

This compilette will specialize this code with an ``optimized''
version at run-time. For example the previous code will be specialized
as
\begin{verbatim}
int multiply (int a)
{
  return a * 42;
}
\end{verbatim}

Please note that the value 42 is choosed by the user and can not be
include into the code before run-time.

This specialized version should be faster than the previous one because
\begin{itemize}
\item the code is less specialized (Well, for a 1 instruction
  function, it's not so evident, but you get the idea)
\item the function contain less parameter, which use less memory and
  less register
\end{itemize}


\subsubsection{Cell version}

Use the command \texttt{make cell} to build the program.

The \texttt{cell} version contain 2 files :
\begin{description}
\item[simple-worker-cell.c] contain the initial SPU code. It will
  \begin{enumerate}
  \item download the binary code in a buffer
  \item use this buffer as a function
  \item call this function for all incoming parameter
  \end{enumerate}
\item[simple-multiply-cell.hg] is the code for the PPU. It will
  \begin{enumerate}
  \item generate a specialized code depending on the data given by the user.
  \item sent it to the worker
  \item use the worker 10 times for printing a array of multiplied values
  \end{enumerate}
\end{description}

The cell ccompilette is simple as :

\begin{lstlisting}
#cpu cell

typedef int (*pifi)(int);
pifi multiplyFunc; 

pifi multiplyCompile(int multiplyValue)
{
 insn *code= (insn *)_malloc_align(1024, 7);
 printf("Code generation for multiply value %d\n", multiplyValue);
  #[
	.org	code
	mpyi    $3, $3, (multiplyValue) 
	bi $lr 
  ]#;
  printf("Code generated\n");
  return (pifi)code;
}
\end{lstlisting} % $

\begin{description}
\item[line 3 and 4] define a type pointer on a function which take one
  parameter
\item[line 8] alloc a block in memory where the function will be generated.
\item[line 10] The token \verb|#[| define the beginning of the
  compilette block
\item[line 11] define the beginning address of the function
\item[line 12 and 13] will generate 2 binary instructions. The
  \texttt{mpyi} instruction take the \texttt{multiplyValue} as
  parameter.

  \texttt{bi \$lr} is the return instruction.

\item[line 14] The token \verb|]#| define the end of the compilette block
\end{description}

\subsubsection{Itanium version}

Use the command \texttt{make ia64} to build the program
\texttt{simple-multiply-ia64}. Run it !

\begin{lstlisting}
#cpu ia64

typedef int (*pifi)(int);
pifi multiplyCompile(int multiplyValue)
{
  insn *code= (insn *)calloc(1024, sizeof (insn));
  printf("Code generation for multiply value %d\n", multiplyValue);
  #[
	.org	code
	.proc   code+16, 0
	mov	r33 = (multiplyValue)  
	nop.i 22
	nop.i 22 ;;

	setf.sig f32 = r32
	setf.sig f33 = r33
	nop.i 22 ;;

	nop.m 22
	xmpy.l  f32 = f32, f33 
	nop.i 22 ;;

	nop.m 22
	getf.sig r8= f32
	br.ret.sptk.many b0 ;;
  ]#;
  iflush (code, asm_pc);
  printf("Code generated\n");
  return (pifi)code;
}
\end{lstlisting}

The Itanium version is more complicated due to the fact that this
processor does not have integer multiplication.

The \texttt{setf.sig} instruction convert integer values to floating
point values and the \texttt{getf.sig} does the opposite.

\subsubsection{Power4 version}

Use the command \texttt{make power4} to build the program
\texttt{simple-multiply-power4}. Run it !

\begin{lstlisting}
#cpu power4

typedef int (*pifi)(int);
pifi multiplyCompile(int multiplyValue)
{
  insn *code= (insn *)calloc(1024, sizeof (insn));
  printf("Code generation for multiply value %d\n", multiplyValue);
  #[
	.org	code
	mulli r3, r3, (multiplyValue)  
	blr
  ]#;
  iflush (code, asm_pc);
  printf("Code generated\n");
  return (pifi)code;
}
\end{lstlisting}

The compilette code is similar to the cell one except for the
\texttt{mulli} instruction.

\section{Porting \hpbcg}

Porting \hpbcg to a new architecture should be as simple than the
architectural model you plan to target.

\subsection{Architecture description}

The actual version contain processor description for 
\begin{description}
\item[cell.isa] This file contain all SPU instruction description
\item[ia64.isa] This file contain all instruction set description
\item[power4.isa] This file contain all instruction set description
\end{description}

A processor description file should contain
\begin{description}
\item[Comments] A comments line is a line starting with \#
\item[Arch length] A line containing the architecture name and the bit
  length of one instruction. For instance the first lone of the 
\verb|cell.isa| containing the cell description contain :
\begin{verbatim}
cell 32
\end{verbatim}
\item[Instruction description] Each line of this part describe one
  machine instruction. Each line is divided in two part separated by a
  \verb-|-. The general for is :

\begin{verbatim}
Binary description | Syntax description
\end{verbatim}

For instance the \verb|cell.isa| description contain a line with :
\begin{verbatim}
 00011000000  r3_7 r2_7  r1_7   | a   r1,r2,r3
\end{verbatim}
  \begin{description}
  \item[The Binary description] contains bits fields describing the
    instruction. In the previous example we have 4 bit fields
    \begin{description}
      \item[00011000000] witch is the opcode of the instruction
        coming from the manual\cite{SPU1} page 55.
      \item[Registers description] \verb|r3_7| which mean that the 3nd
        register should be encoded on 7 bits.
    \end{description}
  \item[Syntax description] contains the instruction syntax allowed to
    be used in compilettes.
  \end{description}

\end{description}

\subsection{isatobcg Parser}


\subsection{\hpbcg Parser}

\section{Assembly languages}

This part is devoted to different assembly languages that \hpbcg

\subsection{cell-spu}

\begin{description}
\item[Integer register names] one of
  \begin{itemize}
  \item \verb|$lr|, \verb|$sp|
  \item \verb|$0| : link register, \verb|$1| : stack pointer,
    \verb|$2| : volatile
  \item \verb|$3| .. \verb|$79| function arguments \& return value, volatile
  \item \verb|$80| .. \verb|$127| local variables, non-volatile
  \end{itemize}
\item[Calling convention] 
\end{description}

\subsection{power and cell-ppu }

\begin{description}
\item[Integer register name]  one of
  \begin{itemize}
  \item \verb|r0| .. \verb|r32|
  \item \verb|r3| 1st function argument \& return value
  \end{itemize}
\item[Calling convention] 
\end{description}

\subsection{ia64}
\begin{description}
\item[Registers name] one of
  \begin{itemize}
  \item \verb|r0| .. \verb|r128|, \verb|f0| .. \verb|f0| are floating
    point or multimedia registers
  \item \verb|r0| is always 0
  \item \verb|r1| is always 1
  \item \verb|f0| is always 0.0
  \end{itemize}
\item[Calling convention] depending on the used datatype, different
  register can be used :
  \begin{itemize}
  \item \verb|r32| is the first integer parameter, \verb|r33| the
    second, etc.
  \item \verb|f8| is the first floating point parameter, \verb|f9| the
    second, etc.
  \item \verb|r8| or \verb|f8| is the return value depending on the
    used data type.
  \end{itemize}
\end{description}

\section{Reporting bug}

Please mail your comments to \url{mailto:hpc@prism.uvsq.fr}

\bibliographystyle{plain}
\bibliography{HPBCG.bib}

\end{document}

% Local Variables: ***
% compile-command:"MonMake HPBCG.pdf" ***
% End: ***
